/* LCM type definition class file
 * This file was automatically generated by lcm-gen
 * DO NOT MODIFY BY HAND!!!!
 * lcm-gen 1.5.2
 */

/**
 * This code is generated via firehose.
 * DO NOT hand edit code.  Make any changes required using the firehose repo instead
 */
package aspn23_lcm;
 
import java.io.*;
import java.util.*;
import lcm.lcm.*;
 
/**
 * Metadata for a magnetic field measurement. In addition to generic metadata information,
 * calibration parameters may be provided to account for effects such as soft iron, scale factor,
 * non-orthogonality, zero-bias, and hard iron. In general, for an num_meas-dimensional measurement,
 * the magnetic field calibration metadata (K and b) shall be used as
 *
 * m_calibrated = K * m_measured - b
 *
 * where m_calibrated, m_measured, and b are num_meas x 1 vectors (scalar for num_meas = 1) and K is
 * an num_meas x num_meas matrix (scalar for num_meas = 1). See magnetic_calibration.md for
 * additional details.
 *
 * More sophisticated approaches that include calibration parameters such as time-varying effects,
 * first-order Gauss-Markov bias models, and calibration parameter uncertainties may be included
 * using an appropriate error model in the measurement message.
 */
public final class metadata_magnetic_field implements lcm.lcm.LCMEncodable
{
    /**
     * Non ASPN. Do not use. Extra field encoding the struct name to disambiguate LCM type fingerprint hashes.
     */
    public byte icd_metadata_magnetic_field;

    /**
     * Description: Standard ASPN metadata header.
     * Units: none
     */
    public aspn23_lcm.type_metadataheader info;

    /**
     * Description: Time at which the measurement is considered to be valid.
     * Units: none
     */
    public aspn23_lcm.type_timestamp time_of_validity;

    /**
     * Description: Standard ASPN mounting information.
     * Units: none
     */
    public aspn23_lcm.type_mounting mounting;

    /**
     * Description: Dimension of measurement for which this metadata is applicable. May be 1, 2, or 3.
     * Units: none
     */
    public short num_meas;

    /**
     * Description: Optional calibration parameter to account for the combined effects of soft iron,
     * scale factor, and non-orthogonality as a unitless num_meas x num_meas matrix. Optional, but if
     * provided, b must also be provided.
     * Units: none
     * LCM Type: double[num_meas][num_meas]
     */
    public double k[][];

    /**
     * Description: Optional calibration parameter to account for the combined effects of zero-bias and
     * hard iron as a num_meas x 1 vector in nanoTesla (nT). Optional, but if provided, K must also be
     * provided.
     * Units: nT
     * LCM Type: double[num_meas]
     */
    public double b[];

 
    public metadata_magnetic_field()
    {
    }
 
    public static final long LCM_FINGERPRINT;
    public static final long LCM_FINGERPRINT_BASE = 0xec9dbdee1877dc68L;
 
    static {
        LCM_FINGERPRINT = _hashRecursive(new ArrayList<Class<?>>());
    }
 
    public static long _hashRecursive(ArrayList<Class<?>> classes)
    {
        if (classes.contains(aspn23_lcm.metadata_magnetic_field.class))
            return 0L;
 
        classes.add(aspn23_lcm.metadata_magnetic_field.class);
        long hash = LCM_FINGERPRINT_BASE
             + aspn23_lcm.type_metadataheader._hashRecursive(classes)
             + aspn23_lcm.type_timestamp._hashRecursive(classes)
             + aspn23_lcm.type_mounting._hashRecursive(classes)
            ;
        classes.remove(classes.size() - 1);
        return (hash<<1) + ((hash>>63)&1);
    }
 
    public void encode(DataOutput outs) throws IOException
    {
        outs.writeLong(LCM_FINGERPRINT);
        _encodeRecursive(outs);
    }
 
    public void _encodeRecursive(DataOutput outs) throws IOException
    {
        outs.writeByte(this.icd_metadata_magnetic_field); 
 
        this.info._encodeRecursive(outs); 
 
        this.time_of_validity._encodeRecursive(outs); 
 
        this.mounting._encodeRecursive(outs); 
 
        outs.writeShort(this.num_meas); 
 
        for (int a = 0; a < this.num_meas; a++) {
            for (int b = 0; b < this.num_meas; b++) {
                outs.writeDouble(this.k[a][b]); 
            }
        }
 
        for (int a = 0; a < this.num_meas; a++) {
            outs.writeDouble(this.b[a]); 
        }
 
    }
 
    public metadata_magnetic_field(byte[] data) throws IOException
    {
        this(new LCMDataInputStream(data));
    }
 
    public metadata_magnetic_field(DataInput ins) throws IOException
    {
        if (ins.readLong() != LCM_FINGERPRINT)
            throw new IOException("LCM Decode error: bad fingerprint");
 
        _decodeRecursive(ins);
    }
 
    public static aspn23_lcm.metadata_magnetic_field _decodeRecursiveFactory(DataInput ins) throws IOException
    {
        aspn23_lcm.metadata_magnetic_field o = new aspn23_lcm.metadata_magnetic_field();
        o._decodeRecursive(ins);
        return o;
    }
 
    public void _decodeRecursive(DataInput ins) throws IOException
    {
        this.icd_metadata_magnetic_field = ins.readByte();
 
        this.info = aspn23_lcm.type_metadataheader._decodeRecursiveFactory(ins);
 
        this.time_of_validity = aspn23_lcm.type_timestamp._decodeRecursiveFactory(ins);
 
        this.mounting = aspn23_lcm.type_mounting._decodeRecursiveFactory(ins);
 
        this.num_meas = ins.readShort();
 
        this.k = new double[(int) num_meas][(int) num_meas];
        for (int a = 0; a < this.num_meas; a++) {
            for (int b = 0; b < this.num_meas; b++) {
                this.k[a][b] = ins.readDouble();
            }
        }
 
        this.b = new double[(int) num_meas];
        for (int a = 0; a < this.num_meas; a++) {
            this.b[a] = ins.readDouble();
        }
 
    }
 
    public aspn23_lcm.metadata_magnetic_field copy()
    {
        aspn23_lcm.metadata_magnetic_field outobj = new aspn23_lcm.metadata_magnetic_field();
        outobj.icd_metadata_magnetic_field = this.icd_metadata_magnetic_field;
 
        outobj.info = this.info.copy();
 
        outobj.time_of_validity = this.time_of_validity.copy();
 
        outobj.mounting = this.mounting.copy();
 
        outobj.num_meas = this.num_meas;
 
        outobj.k = new double[(int) num_meas][(int) num_meas];
        for (int a = 0; a < this.num_meas; a++) {
            if (this.num_meas > 0)
                System.arraycopy(this.k[a], 0, outobj.k[a], 0, (int) this.num_meas);        }
 
        outobj.b = new double[(int) num_meas];
        if (this.num_meas > 0)
            System.arraycopy(this.b, 0, outobj.b, 0, (int) this.num_meas); 
        return outobj;
    }
 
}

