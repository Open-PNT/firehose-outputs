/* LCM type definition class file
 * This file was automatically generated by lcm-gen
 * DO NOT MODIFY BY HAND!!!!
 * lcm-gen 1.5.2
 */

/**
 * This code is generated via firehose.
 * DO NOT hand edit code.  Make any changes required using the firehose repo instead
 */
package aspn23_lcm;
 
import java.io.*;
import java.util.*;
import lcm.lcm.*;
 
/**
 * 2D Raster Image
 */
public final class measurement_image implements lcm.lcm.LCMEncodable
{
    /**
     * Non ASPN. Do not use. Extra field encoding the struct name to disambiguate LCM type fingerprint hashes.
     */
    public byte icd_measurement_image;

    /**
     * Description: Standard ASPN measurement header.
     * Units: none
     */
    public aspn23_lcm.type_header header;

    /**
     * Description: Time at which the measurement is considered to be valid.
     * Units: none
     */
    public aspn23_lcm.type_timestamp time_of_validity;

    /**
     * Description: The number of pixel rows in this image.
     * Units: pixels
     */
    public long height;

    /**
     * Description: The number of pixel columns in this image.
     * Units: pixels
     */
    public long width;

    /**
     * Description: True if the image_data byte order is big endian, false if it is little endian. For
     * raw image_types, this is only applicable for image_types with multi-byte pixels.
     * Units: none
     */
    public boolean is_bigendian;

    /**
     * Enumerated field which specifies the datatype of the pixels represented in this image.
     * Raw images are stored in row-major order. In multi-channel raw images, the first element
     * contains the first pixel of the first channel, the second element contains the first pixel of the
     * second channel, and so on. The data of each multi-byte pixel should be contiguous within the data
     * array with the endianness defined by the is_bigendian field.
     * Example - 2x2 RAW_RGB8 image_data[0] row1 col1 chanR image_data[1] row1 col1 chanG image_data[2]
     * row1 col1 chanB image_data[3] row1 col2 chanR image_data[4] row1 col2 chanG image_data[5] row1 col2
     * chanB image_data[6] row2 col1 chanR image_data[7] row2 col1 chanG image_data[8] row2 col1 chanB
     * image_data[9] row2 col2 chanR image_data[10] row2 col2 chanG image_data[11] row2 col2 chanB
     * Example - 2x2 RAW_GRAY16, is_bigendian = 1 Where byte 1 is the most significant byte (byte1 << 8
     * | byte2): image_data[0] row1 col1 byte1 image_data[1] row1 col1 byte2 image_data[2] row1 col2 byte1
     * image_data[3] row1 col2 byte2 image_data[4] row2 col1 byte1 image_data[5] row2 col1 byte2
     * image_data[6] row2 col2 byte1 image_data[7] row2 col2 byte2
     */
    public byte image_type;

    /**
     * Description: Length of the byte array holding the encoded image. For raw image types, this
     * should be equal to height * width * num_channels * bytes_per_pixel.
     * Units: byte
     */
    public long image_data_length;

    /**
     * Description: Stores the encoded image. Interpretation varies based on the image_type.
     * Units: none
     * LCM Type: int16_t[image_data_length]
     */
    public short image_data[];

    /**
     * The model used to map 3D points in the world to 2D points on the image plane
     */
    public byte camera_model;

    /**
     * Description: The number of coefficients used in camera model.
     * Units: none
     */
    public short num_model_coefficients;

    /**
     * Description: The camera model parameters, size depending on the distortion model.
     * Units: none
     * LCM Type: double[num_model_coefficients]
     */
    public double model_coefficients[];

    /**
     * Description: Number of integrity values.
     * Units: none
     */
    public short num_integrity;

    /**
     * Description: Measurement integrity. Includes the integrity method used and an integrity value
     * (which is to be interpreted based upon the integrity method). The intent of allowing num_integrity >
     * 1 is to report multiple integrity values based on multiple integrity methods.
     * Units: none
     * LCM Type: aspn23_lcm.type_integrity[num_integrity]
     */
    public aspn23_lcm.type_integrity integrity[];

 
    public measurement_image()
    {
    }
 
    public static final long LCM_FINGERPRINT;
    public static final long LCM_FINGERPRINT_BASE = 0x77351e40ed8bb80aL;
 
    /**
     * Windows Bitmaps
     */
    public static final byte IMAGE_TYPE_BMP = (byte) 0;
    /**
     * Portable Network Graphics
     */
    public static final byte IMAGE_TYPE_PNG = (byte) 1;
    /**
     * Joint Photographic Experts Group
     */
    public static final byte IMAGE_TYPE_JPG = (byte) 2;
    /**
     * Tag Image File Format
     */
    public static final byte IMAGE_TYPE_TIFF = (byte) 3;
    /**
     * Single channel raw gray scale image. One byte per pixel.
     */
    public static final byte IMAGE_TYPE_RAW_GRAY8 = (byte) 4;
    /**
     * Three channel raw RGB image. One byte per pixel per channel.
     */
    public static final byte IMAGE_TYPE_RAW_RGB8 = (byte) 5;
    /**
     * Three channel raw BGR image. One byte per pixel per channel.
     */
    public static final byte IMAGE_TYPE_RAW_BGR8 = (byte) 6;
    /**
     * Four channel raw RGBA image. One byte per pixel per channel.
     */
    public static final byte IMAGE_TYPE_RAW_RGBA8 = (byte) 7;
    /**
     * Four channel raw BGRA image. One byte per pixel per channel.
     */
    public static final byte IMAGE_TYPE_RAW_BGRA8 = (byte) 8;
    /**
     * Single channel raw gray scale image. Two bytes per pixel.
     */
    public static final byte IMAGE_TYPE_RAW_GRAY16 = (byte) 9;
    /**
     * Single channel raw gray scale image. Eight bytes per pixel.
     */
    public static final byte IMAGE_TYPE_RAW_GRAYFLOAT64 = (byte) 10;
    /**
     * A 10 parameter model, 4 parameters composing the 2D focal length fc = (fx, fy) and camera
     * principal point cc = (cx, cy) in pixels, a model of radial and tangential distortion specified using
     * the 5 parameters (kc1, kc2, kc3, kc4, kc5). And the skew parameter, alpha_c. Mapping from 3D points
     * in the world to 2D points in the image is described at
     * http://www.vision.caltech.edu/bouguetj/calib_doc/htmls/parameters.html
     */
    public static final byte CAMERA_MODEL_ASPN_PINHOLE_PLUMB_BOB = (byte) 0;
    /**
     * A 4 parameter model, modeling only the the 2D focal length fc = (fx, fy) and camera principal
     * point cc = (cx, cy). Effectively using the same model as described in described at
     * http://www.vision.caltech.edu/bouguetj/calib_doc/htmls/parameters.html, with all distortion and skew
     * parameters zeroed out
     */
    public static final byte CAMERA_MODEL_ASPN_LINEAR_MODEL = (byte) 1;

    static {
        LCM_FINGERPRINT = _hashRecursive(new ArrayList<Class<?>>());
    }
 
    public static long _hashRecursive(ArrayList<Class<?>> classes)
    {
        if (classes.contains(aspn23_lcm.measurement_image.class))
            return 0L;
 
        classes.add(aspn23_lcm.measurement_image.class);
        long hash = LCM_FINGERPRINT_BASE
             + aspn23_lcm.type_header._hashRecursive(classes)
             + aspn23_lcm.type_timestamp._hashRecursive(classes)
             + aspn23_lcm.type_integrity._hashRecursive(classes)
            ;
        classes.remove(classes.size() - 1);
        return (hash<<1) + ((hash>>63)&1);
    }
 
    public void encode(DataOutput outs) throws IOException
    {
        outs.writeLong(LCM_FINGERPRINT);
        _encodeRecursive(outs);
    }
 
    public void _encodeRecursive(DataOutput outs) throws IOException
    {
        outs.writeByte(this.icd_measurement_image); 
 
        this.header._encodeRecursive(outs); 
 
        this.time_of_validity._encodeRecursive(outs); 
 
        outs.writeLong(this.height); 
 
        outs.writeLong(this.width); 
 
        outs.writeByte( this.is_bigendian ? 1 : 0); 
 
        outs.writeByte(this.image_type); 
 
        outs.writeLong(this.image_data_length); 
 
        for (int a = 0; a < this.image_data_length; a++) {
            outs.writeShort(this.image_data[a]); 
        }
 
        outs.writeByte(this.camera_model); 
 
        outs.writeShort(this.num_model_coefficients); 
 
        for (int a = 0; a < this.num_model_coefficients; a++) {
            outs.writeDouble(this.model_coefficients[a]); 
        }
 
        outs.writeShort(this.num_integrity); 
 
        for (int a = 0; a < this.num_integrity; a++) {
            this.integrity[a]._encodeRecursive(outs); 
        }
 
    }
 
    public measurement_image(byte[] data) throws IOException
    {
        this(new LCMDataInputStream(data));
    }
 
    public measurement_image(DataInput ins) throws IOException
    {
        if (ins.readLong() != LCM_FINGERPRINT)
            throw new IOException("LCM Decode error: bad fingerprint");
 
        _decodeRecursive(ins);
    }
 
    public static aspn23_lcm.measurement_image _decodeRecursiveFactory(DataInput ins) throws IOException
    {
        aspn23_lcm.measurement_image o = new aspn23_lcm.measurement_image();
        o._decodeRecursive(ins);
        return o;
    }
 
    public void _decodeRecursive(DataInput ins) throws IOException
    {
        this.icd_measurement_image = ins.readByte();
 
        this.header = aspn23_lcm.type_header._decodeRecursiveFactory(ins);
 
        this.time_of_validity = aspn23_lcm.type_timestamp._decodeRecursiveFactory(ins);
 
        this.height = ins.readLong();
 
        this.width = ins.readLong();
 
        this.is_bigendian = ins.readByte()!=0;
 
        this.image_type = ins.readByte();
 
        this.image_data_length = ins.readLong();
 
        this.image_data = new short[(int) image_data_length];
        for (int a = 0; a < this.image_data_length; a++) {
            this.image_data[a] = ins.readShort();
        }
 
        this.camera_model = ins.readByte();
 
        this.num_model_coefficients = ins.readShort();
 
        this.model_coefficients = new double[(int) num_model_coefficients];
        for (int a = 0; a < this.num_model_coefficients; a++) {
            this.model_coefficients[a] = ins.readDouble();
        }
 
        this.num_integrity = ins.readShort();
 
        this.integrity = new aspn23_lcm.type_integrity[(int) num_integrity];
        for (int a = 0; a < this.num_integrity; a++) {
            this.integrity[a] = aspn23_lcm.type_integrity._decodeRecursiveFactory(ins);
        }
 
    }
 
    public aspn23_lcm.measurement_image copy()
    {
        aspn23_lcm.measurement_image outobj = new aspn23_lcm.measurement_image();
        outobj.icd_measurement_image = this.icd_measurement_image;
 
        outobj.header = this.header.copy();
 
        outobj.time_of_validity = this.time_of_validity.copy();
 
        outobj.height = this.height;
 
        outobj.width = this.width;
 
        outobj.is_bigendian = this.is_bigendian;
 
        outobj.image_type = this.image_type;
 
        outobj.image_data_length = this.image_data_length;
 
        outobj.image_data = new short[(int) image_data_length];
        if (this.image_data_length > 0)
            System.arraycopy(this.image_data, 0, outobj.image_data, 0, (int) this.image_data_length); 
        outobj.camera_model = this.camera_model;
 
        outobj.num_model_coefficients = this.num_model_coefficients;
 
        outobj.model_coefficients = new double[(int) num_model_coefficients];
        if (this.num_model_coefficients > 0)
            System.arraycopy(this.model_coefficients, 0, outobj.model_coefficients, 0, (int) this.num_model_coefficients); 
        outobj.num_integrity = this.num_integrity;
 
        outobj.integrity = new aspn23_lcm.type_integrity[(int) num_integrity];
        for (int a = 0; a < this.num_integrity; a++) {
            outobj.integrity[a] = this.integrity[a].copy();
        }
 
        return outobj;
    }
 
}

